#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os
from openai import OpenAI
import hashlib
import base64
from typing import Any, Dict, List
from config_reader import Config

# Initialize the OpenAI client
client = OpenAI(api_key=Config.OPENAI_API_KEY)

class ValueEncryptor:
    def __init__(self):
        self.value_map: Dict[str, Any] = {}
    
    def encrypt_value(self, value: Any) -> str:
        # Convert value to string and create a hash
        value_str = str(value)
        # Create a hash of the value
        hash_obj = hashlib.sha256(value_str.encode('utf-8'))
        # Take first 6 characters of hex digest
        hash_str = hash_obj.hexdigest()[:6]
        # Create a placeholder with a clear format
        placeholder = f"<VAL_{hash_str}>"
        # Store the mapping if it's a new value
        if placeholder not in self.value_map:
            self.value_map[placeholder] = value
        return placeholder
    
    def decrypt_text(self, text: str) -> str:
        # No need to sort as placeholders have fixed format and won't conflict
        result = text
        for placeholder, value in self.value_map.items():
            result = result.replace(placeholder, str(value))
        return result

def encrypt_results(results: List[dict], encryptor: ValueEncryptor) -> List[dict]:
    encrypted_results = []
    for item in results:
        encrypted_item = {
            "query": item["query"],  # Keep SQL query as plain text
            "result": []
        }
        # Encrypt each row in the result
        for row in item["result"]:
            encrypted_row = {}
            for key, value in row.items():
                # Keep the keys as plain text, encrypt only the values
                encrypted_row[key] = encryptor.encrypt_value(value)
            encrypted_item["result"].append(encrypted_row)
        encrypted_results.append(encrypted_item)
    return encrypted_results

def summarize_sql_result(user_question: str, sqls: str, all_results: list, language: str = "en") -> str:
    """
    Calls OpenAI to produce a user-friendly summary of multiple SQL statements and their results.
    """
    # Create an encryptor instance
    encryptor = ValueEncryptor()
    
    # Encrypt the results before sending to OpenAI
    encrypted_results = encrypt_results(all_results, encryptor)
    
    # Build content string with encrypted results
    content_str = f"User question: {user_question}\n\n"
    content_str += f"SQL queries generated by the assistant:\n{sqls}\n\n"
    
    for idx, item in enumerate(encrypted_results, start=1):
        content_str += f"Statement #{idx}:\nSQL Query:\n{item['query']}\nResult:\n{repr(item['result'])}\n\n"

    # Prepare the system message based on language
    if language == "zh":
        system_msg = """你是一个人工智能，可以生成多个 SQL 语句的简洁、用户友好的摘要及其相应的结果。请注意：
1. 使用清晰自然的语言直接回答用户问题
2. 必须完整展示所有结果，不允许对任何列表进行截断或省略
3. 即使结果很长，也要完整展示每一项
4. 禁止使用"等"、"..."或类似的省略表示"""
    else:
        system_msg = """You are an AI that produces a concise, user-friendly summary of multiple SQL statements and their corresponding results. Important instructions:
1. Answer the user's question in clear, natural language
2. You MUST show ALL results in their entirety
3. NEVER truncate or omit any items from lists, no matter how long they are
4. DO NOT use "etc.", "..." or any form of abbreviation
5. Include every single item in the results"""
        
    # Prepare messages for OpenAI
    messages = [
        {
            "role": "system",
            "content": system_msg
        },
        {
            "role": "user",
            "content": content_str
        }
    ]
    
    # Make the request to OpenAI
    response = client.chat.completions.create(
        model="gpt-3.5-turbo",
        messages=messages,
        temperature=0.7,
        max_tokens=400)

    # Extract the assistant's answer and decrypt the values
    summary_text = response.choices[0].message.content.strip()
    decrypted_summary = encryptor.decrypt_text(summary_text)
    
    # Create a Response object with metadata
    class Response(str):
        pass
        
    response = Response(decrypted_summary)
    response.metadata = {
        "messages": messages,  # 记录发送给 OpenAI 的消息
        "raw_summary": summary_text,  # 加密的摘要
        "decrypted_summary": decrypted_summary,  # 解密后的摘要
        "encrypted_results": encrypted_results,  # 加密后的结果
        "value_map": encryptor.value_map,  # 添加 encryptor 的映射关系
        "model": "gpt-3.5-turbo",
        "temperature": 0.7,
        "max_tokens": 400
    }
    
    return response
