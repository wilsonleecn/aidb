#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os
from openai import OpenAI
import hashlib
import base64
from typing import Any, Dict, List
from config_reader import Config

# Initialize the OpenAI client
client = OpenAI(api_key=Config.OPENAI_API_KEY)

class ValueEncryptor:
    def __init__(self):
        self.value_map: Dict[str, Any] = {}
        self._counter = 0
    
    def encrypt_value(self, value: Any) -> str:
        # Generate a unique placeholder
        placeholder = f"ENCRYPTED_{self._counter}"
        self._counter += 1
        # Store the mapping
        self.value_map[placeholder] = value
        return placeholder
    
    def decrypt_text(self, text: str) -> str:
        # Replace all placeholders in the text with their original values
        result = text
        for placeholder, value in self.value_map.items():
            result = result.replace(placeholder, str(value))
        return result

def encrypt_results(results: List[dict], encryptor: ValueEncryptor) -> List[dict]:
    encrypted_results = []
    for item in results:
        encrypted_item = {
            "query": item["query"],  # Keep SQL query as plain text
            "result": []
        }
        # Encrypt each row in the result
        for row in item["result"]:
            encrypted_row = {}
            for key, value in row.items():
                # Keep the keys as plain text, encrypt only the values
                encrypted_row[key] = encryptor.encrypt_value(value)
            encrypted_item["result"].append(encrypted_row)
        encrypted_results.append(encrypted_item)
    return encrypted_results

def summarize_sql_result(user_question: str, sqls: str, all_results: list) -> str:
    """
    Calls OpenAI to produce a user-friendly summary of multiple SQL statements and their results.
    
    Args:
        user_question (str): The original user question.
        sql_answer (str): The raw SQL answer from OpenAI (could contain multiple statements).
        all_results (list): A list of dicts, where each dict has {"query": <SQL>, "result": <list of rows>}.

    Returns:
        str: A natural-language summary of the results suitable for displaying to the user.
    """

    # Create an encryptor instance
    encryptor = ValueEncryptor()
    
    # Encrypt the results before sending to OpenAI
    encrypted_results = encrypt_results(all_results, encryptor)
    
    # Build content string with encrypted results
    content_str = f"User question: {user_question}\n\n"
    content_str += f"SQL queries generated by the assistant:\n{sqls}\n\n"
    
    for idx, item in enumerate(encrypted_results, start=1):
        content_str += f"Statement #{idx}:\nSQL Query:\n{item['query']}\nResult:\n{repr(item['result'])}\n\n"

    # We'll feed the above to the model in the user message
    # So the system prompt sets the role, the user prompt includes the question, the query, the results
    messages = [
        {
            "role": "system",
            "content": (
                "You are an AI that produces a concise, user-friendly summary of multiple SQL statements "
                "and their corresponding results. Address the user's question directly in clear, natural language. "
                # "If the user's question contains Chinese characters, respond in Chinese. Otherwise, respond in English."
            )
        },
        {
            "role": "user",
            "content": content_str
        }
    ]

    # Make the request to OpenAI
    response = client.chat.completions.create(
        model="gpt-3.5-turbo",
        messages=messages,
        temperature=0.7,
        max_tokens=400)

    # Extract the assistant's answer and decrypt the values
    summary_text = response.choices[0].message.content.strip()
    decrypted_summary = encryptor.decrypt_text(summary_text)
    return decrypted_summary
